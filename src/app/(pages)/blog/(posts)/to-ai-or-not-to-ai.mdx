export const metadata = {
    title: 'To AI or Not to AI',
    description: `AI augments programming, but overuse undermines learning`,
    series: 'Path of becoming a good software engineer',
    publishedAt: new Date('2025/12/22'),
}

There are two types of AI-assisted developers: those who use AI to augment their understanding, and those who let AI replace their thinking entirely.

#### Quick history of tech bubbles

I define a bubble in any industry as a period when too many companies pursue similar ideas around a new technology with seemingly unlimited potential, but without a market to sustain it.

Software engineering moves in cycles, and tech has seen some of the biggest bubbles so far. The dot-com bubble produced undoubtedly useful products, but the balloon of unfathomable hype burst as quickly as it was inflated. Web3 generated more hype than real value and has left far less impact on the world than the dot-com era - at least so far. Another similar scenario was the surge in internet usage during the Covid pandemic.

Each bubble first drives adoption of a new trend, increasing demand for engineers to build and maintain it. When the hype fades, companies face the end of growth and are forced to lay off recently hired developers.

Nowadays, we are witnessing an AI bubble. Many similar (and some genuinely unique) products surround the undeniable potential for high value, bringing with them unimaginable levels of hype - though much of it is, in my opinion, negative. AI fanatics who promote the idea of AI gradually replacing programmers altogether are discouraging potential newcomers from pursuing software engineering. On the other hand, AI skeptics often do not even try to understand the real experiences of people using AI to meaningfully improve their daily workflows. You can either view the entire bubble as negative, or you can recognize both the overhyped ideas and the real value within.

Each time technology has changed - from manual switches to punch cards, assembly, low- and high-level languages, to web and mobile - the nature of concern has shifted, but more programmers have been needed every time. Only when overall demand is satisfied do employment levels begin to fall.

When programming became easier through higher-level abstractions, more programmers created larger and more complex programs. Jevons paradox describes how technological progress that increases resource efficiency can paradoxically lead to increased total consumption of that resource - and it holds true here. As technology grew more capable, successful projects did not stop emerging; they simply became more complex. Engineers must continually challenge themselves to accomplish new feats, and AI is just the latest challenge in this ongoing cycle.

#### AI: expectation vs. reality

The industry has never invested more hope (and money) into a potential future where AI either helps us push engineering limits further than ever, or - in some minds - even takes on these challenges independently.

In the simplest terms, text generation AI works by probabilistically finding the most likely next word to follow a given prompt, adding that word to build context, and repeating this process. And that is exactly how we should view and use it - as fast autocomplete, good enough at predicting what comes next that we are willing to invest even more money into it.

Using AI for software development is essentially applying a context-full grammar of AI inference to build a context-free grammar of code.

#### Defining vibe coding

Because AI allows anyone to create a website, tool, or game from scratch without prior experience, more people are intrigued by software development than ever. In this space, a phrase you will encounter sooner rather than later is "vibe coding", but everyone seems to define it differently, with little overlap between interpretations:

- "Non-developers writing code via AI"
- "Ignoring the code entirely and only prompting"
- "Doing most of the work via plain English while still paying attention to code"
- "Using autocomplete in a code editor"

I prefer to use the phrase "agentic coding" for prompting AI that uses tools to generate code, and "vibe coding" as only a subset of agentic coding - specifically, the practice of not reading the generated code afterward. You can often spot this practice when the developer is more likely to copy-paste the error into the AI prompt than to read the code directly.

#### Dangers of overreliance on AI

This way of working as a whole reveals a deeper problem - many people who claim Copilot helped them with software development frustrations were bad developers to begin with.  Letting AI write all your code without oversight is easy, but it hinders your ability to remember and deeply understand concepts when you use it as a substitute for your own thinking.

Instead of typing out the next obvious statement yourself, you wait for the AI assistant to tell you what you were about to write. Instead of owning your program's concepts, data flows, and architecture, you let AI lead the programming - introducing bugs, outdated libraries, and solutions that seem good at first but later prove to be weak links in large-scale development.

AI labs are already working on these problems. Multi-pass reasoning and RAG have largely solved hallucinations. However, with inherently large and complex codebases, AI struggles to maintain the necessary context about the system, resulting in worse solutions.

When the process becomes unenjoyable, only the outcome matters. Bad engineers stop exploring, improving, and caring. Being a real programmer means taking the steering wheel and using your brain. AI may eventually make today's software writing methods obsolete, but each engineer must choose: either enjoy writing code manually (though the market may not pay for this enjoyment) or adapt to whatever new building methods emerge.

Knowing what is correct, what proper implementation looks like, and having a sense of where that elusive bug could be hiding - these are the skills most developers starting their careers with AI are overlooking.

#### Impact on students

The knowledge and wisdom gap becomes most visible in education principles. While experts focus their energy on problems they want to solve, novices - including students and junior engineers - must tackle small, seemingly boring problems before seeing the big picture. Developing an intuition for which consequences stem from which decisions is an art learned through trial and error. A refined taste for what looks right also helps obtain better outcomes from AI by recognizing when it is hallucinating or veering off on strange tangents which happens regularly.

AI allows novices to shortcut the essential initial struggles of learning-from-mistakes phase - the stage when critical thinking and intuition develop. It is human nature to choose the easiest path, and this temptation especially affects novices who want to be productive without fully understanding the solution. Offloading understanding may seem easier at first, and it is hard to resist this temptation. As a student myself, I see an alarming number of peers solving assigned problems by having AI do it for them. Large corporations offering students free access to these tools is a brilliant marketing strategy - students who use AI this way now are likely to become a lifelong customer.

If you are new to software development, do not sacrifice your early learning years and skip challenges for the sake of virtual productivity by outsourcing knowledge to AI. Relying on AI to get unstuck, just as you would ask senior colleagues for advice, is fine. However, if you end up being spoonfed solutions you do not understand and simply copy-paste them without grasping why they are correct, advancing your engineering skills becomes a serious challenge.

#### Use in companies

These educational concerns become company-wide issues when students enter the workforce, directly shaping how organizations should approach AI adoption.

I see AI as a $20 intern who is not emotionally attached to changes or criticism of their code. Part of being a senior developer is designing systems that prevent juniors from shooting themselves in the foot - unblocking the complex parts so that everyone (including AI) can understand and contribute.

If more companies close their doors to juniors, the next generation of juniors will not be trained, similar to what happened during the dot-com boom and bust. This leads to future boom cycles where opportunities flourish for those with the right skills.

When it comes to startups, both investors and I encourage AI usage because fast iteration with frequent feedback is essential for finding product-market fit. AI excels at rapid prototyping and simple tasks, making it invaluable for early-stage startups testing ideas.

#### Effective use of AI

Beyond fast prototyping capabilities, daily work is enriched with AI as an internet and documentation search tool. Some questions are too specific for search engines like Google but simple enough for AI to provide relevant results. As discussed above, asking AI questions to understand how something works - rather than using it to avoid confronting what you do not understand - is a great productivity booster.

AI is also tranforming the software engineering industry and changing how write and view software. In the past, technologies were chosen for how quickly they enabled shipping. Since AI models were trained on this code, we now have an incentive not to change the surface (e.g., syntax) of technologies. Changes would make all the training data obsolete, creating potential hallucination points and general inaccuracy without using tooling. Unfortunately, we are less likely to meaningfully change our technologies or usage patterns because for the growing number of AI-dependent developers, trading AI's coding speed for better ergonomics will not seem worthwile.

There is a lot of throwaway and legacy code that is not worth writing or reading. This code should be easy to discard (which is difficult for developers emotionally attached to their code) and rewrite, since much code is not worth the time it takes to write it. This explains why most projects are littered with many third-party packages - developers do not want to reinvent the wheel. These packages and AI-generated code both abstract away implementation details, but AI-generated implementation still lives inside your project, making changes easier than proposing fixes to external packages maintained by others.

Good code has two characteristics - it solves the problem, and it does not suck to read. People often focus only on bad readability when discussing AI code generation, but it should not affect it. If AI-generated code is better than what you would write, your should not use it blindly - it will do more harm long-term. Ideally, you work on the fun and important portions of the code while letting AI handle boilerplate and tedious, repetitive, but non-mission-critical parts.

Overall code quality largely depends on whether you lead AI or AI leads you. Do not let AI choose the approach to solving the problem. You should know how AI-generated parts should behave so you can quickly steer it away from incorrect implementations; otherwise, AI's mistakes will wait for you to fix later. While strongly-typed languages help AI generate more correct code through type checking, and tests verify behavior under real workloads (which most testing cannot fully simulate), code review has become even more critical - expecting all AI code to be production-ready is foolish.

Most development work is not artisanal. As long as it works and the UX is good enough, nobody (except your team) cares how clean the code is. With correct AI usage and prior knowledge, you can spend more time on architecture and design since development time for mediocre code has dropped dramatically. Still, there is beauty in artisanal software made by someone who wanted it and knew how to make it great.

AI might be probabilistic, but what matters is whether you can make sense of the result and whether your guardrails - type safety, tests and code review - hold.

#### Why programmers are not obsolete

The magic of these tools is not that they eliminate the need for knowledge. It's that you can write code you do not need or want to solve problems not significant enough to warrant solving manually, but annoying enough that you would use a ready-made solution if offered one.

Anyone told that "vibe coding" means "you do not need developers" has been misled. When humanity invented better farming tools, it did not mean everyone became a farmer or that professionals became obsolete. The opposite happened - fewer, but expert farmers now produce food for more people than ever before because they understand the field and use tools to be more productive.

While more developers use AI and everyone is being promised 10x development efficiency, the actual software we use daily is not and will not get any better this way.

Senior engineers must guide AI suggestions with hard-won engineering wisdom. You cannot escape learning - it is not magic. Instead, you need to understand the domain to use AI effectively.

AI will not replace programmers, it will transform their jobs and create new opportunities, such as software security and maintaining (overly) complex AI-generated codebases.

Computer science is about systematic thinking, not just writing code. You still need to know how code works if you want to be a coder.

#### Too long, can't / won't read

Use AI for boilerplate and research, not as a replacement for understanding. Junior developers especially must build fundamentals through practice, not prompting, or risk becoming dependent debuggers rather than skilled engineers.

#### External sources

- [ThePrimeagen: Why I quit Copilot](https://youtu.be/GkmUwDXvWiQ)
- [Erik Dietrich: How Developers Stop Learning: Rise of the Expert Beginner](https://daedtech.com/how-developers-stop-learning-rise-of-the-expert-beginner/)
- [Theo: Are junior devs screwed](https://youtu.be/76K2r2UFeM4)
- [Theo: AI has rewired my brain](https://youtu.be/6koQP6-6mtY)
- [Thomas Ptacek: My AI Skeptic Friends Are All Nuts](https://fly.io/blog/youre-all-nuts/)
- [Lukas Atkinson: Net-Negative Cursor](https://lukasatkinson.de/2025/net-negative-cursor/)
- [Tim Oâ€™Reilly: The End of Programming as We Know It](https://www.oreilly.com/radar/the-end-of-programming-as-we-know-it/)
- [Geoffrey Huntley: Dear Student: Yes, AI is here, you're screwed unless you take action...](https://ghuntley.com/screwed/)
- [ThePrimeagen: A Rant About Professional Programming](https://youtu.be/o-XBUEjzBX8)
- [Jj: The Copilot Delusion](https://deplet.ing/the-copilot-delusion/)
- [Boyd Kane: Experts have it easy](https://boydkane.com/essays/experts)
- [ThePrimeagen & DHH: DHH Is Right About Everything](https://youtu.be/mTa2d3OLXhg)
- [Theo: Please stop vibe coding like this](https://youtu.be/6TMPWvPG5GA)
